## 1
#### 1. Just-In-Time-компилятор позволяет
>todo
#### 2. Для разработки программ на языке Java необходима установка
>todo
#### 3. Запуск Java-программы производится
>todo
#### 4. Использование языковой виртуальной машины позволяет добиться
>todo
#### 5. Компиляция исходного кода производится
>todo
#### 6. Особенностью языка программирования Java является
>todo
#### 7. Пакеты служат для
>todo
#### 8. Сигнатура функции ```main``` имеет вид
>todo
#### 9. Синтаксис языка программирования Java схож с синтаксисом языка
>todo
#### 10. Структурными частями простейшего Java-проекта являются
>todo
#### 11. Точкой входа в любую Java-программу является
>todo
#### 12. Язык программирования Java является
>todo

## 2
#### 13. В выражении, содержащем переменные типа ```byte, short, char``` происходит автоматическое повышение типа до
>todo
#### 14. В выражении, содержащем переменные типа ```double``` и ```long```, происходит автоматическое повышение типа до
>todo
#### 15. В выражении, содержащем переменные типа ```float``` и ```double```, происходит автоматическое повышение типа до
>todo
#### 16. В выражении, содержащем переменные типа ```float```, происходит автоматическое повышение типа до
>todo
#### 17. В выражении, содержащем переменные типа ```int``` и ```long```, происходит автоматическое повышение типа до
>todo
#### 18. К классам-оберткам над элементарными типами данных не относится
>todo
#### 19. К типам с плавающей запятой относится тип
>todo
#### 20. К целочисленным типам данных Java не относится тип
>todo

## 3
#### 21. В Java ссылки всегда передаются
>todo
#### 22. Значение ```null``` используется в Java
>todo
#### 23. Объект может быть передан по ссылке
>todo
#### 24. Объект называется достижимым, если
>todo
#### 25. Преобразование типа переменной подкласса к типу суперкласса
>todo
#### 26. Преобразование типа переменной суперкласса к типу подкласса
>todo
#### 27. Приведение ссылочных типов возможно
>todo
#### 28. Прямое присваивание одной ссылке значения другой ссылки приведет к тому
>todo

## 4
#### 29. Для представления символов в Java используется кодировка
>todo
#### 30. Изменение отдельного символа строки
>todo
#### 31. Получение отдельного символа строки
>todo
#### 32. При именовании переменных в Java не допускаются
>todo
#### 33. Строковые литералы в Java являются
>todo
#### 34. Тип ```char``` относится к
>todo
#### 35. У переменных типа ```String``` нет встроенных функций, поддерживающих следующую операцию над строками
>todo

## 5
#### 36. Выберите метод, не преобразующий строку
>todo
#### 37. Для какого потока не является необходимым вызов метода ```close```
>todo
#### 38. К стандартным потокам ввода-вывода Java не относится
>todo
#### 39. Пакет ```java.lang``` является
>todo
#### 40. Пакет ```java.util``` является
>todo
#### 41. Строка не может быть преобразована в число типа ```double``` применением
>todo
#### 42. Строка не может быть преобразована в число типа ```int``` применением
>todo

## 6
#### 43. Глубокое копирование массива объектов может быть достигнуто
>todo
#### 44. Глубокое копирование массива объектов — это…
>todo
#### 45. К основному недостатку массива по сравнению с коллекцией относят
>todo
#### 46. Коллекция — это…
>todo
#### 47. Основные типы коллекций в Java не включают
>todo

## 7
#### 48. В языке Java
>todo
#### 49. Выберите оператор, не являющийся оператором цикла
>todo
#### 50. Выберите оператор, являющийся оператором ветвления
>todo
#### 51. Выберите оператор, являющийся оператором перехода
>todo
#### 52. Оператор ```switch``` чаще всего используется
>todo
#### 53. Скомпилируется ли следующий код:
```Java
int i; int j; (false ? i: j) = 55;
```
>todo
#### 54. Цикл ```for``` в форме ```for each``` используется
>todo

## 8
#### 55. Выберите ложное высказывание относительно конструкторов в классах Java
>todo
#### 56. Выберите ложное высказывание относительно конструкторов в классах Java
>todo
#### 57. Для метода с одним параметром, которым является Java-объект, его поля будут передаваться
>todo
#### 58. Методы с модификатором ```final```
>todo
#### 59. Перегрузка методов — это
>todo
#### 60. Поле с модификатором ```final``` не может быть проинициализирована
>todo
#### 61. При перегрузке методов
>todo
#### 62. Статические методы и поля класса — это элементы…
>todo

## 9
#### 63. Анонимный класс — это
>todo
#### 64. Выберите ложное высказывание
>todo
#### 65. Выберите ложное высказывание о вложенных классах
>todo
#### 66. Для вызова метода суперкласса в классе-потомке (при наличии в классе-потомке одноименного метода) нужно
>todo
#### 67. Для переопределения метода в классе потомке достаточно
>todo
#### 68. Для указания того, что класс является подклассом используется
>todo
#### 69. Если в суперклассе есть один конструктор с параметрами, а в классе-потомке определен новый конструктор, не содержащий вызов конструктора суперкласса, то
>todo
#### 70. Ключевое слово ```super``` нельзя использовать
>todo
#### 71. Переопределение методов при наследовании позволяет
>todo

## 10
#### 72. В интерфейсе все поля являются по умолчанию
>todo
#### 73. В интерфейсе все функции являются по умолчанию
>todo
#### 74. Выберите ложное высказывание об абстрактных классах
>todo
#### 75. Выберите ложное высказывание об интерфейсах
>todo
#### 76. Динамическая диспетчеризация методов позволяет
>todo
#### 77. Для расширения интерфейса используется ключевое слово
>todo
#### 78. Для создания классов, которые не могут иметь потомков, применяется
>todo
#### 79. Для указания того, что класс реализует интерфейс используется
>todo
#### 80. Интерфейс — это
>todo
#### 81. Класс с модификатором ```final```
>todo

## 11
#### 82. Выберите ложное высказывание о перечислениях
>todo
#### 83. Выберите ложное высказывание о перечислениях
>todo
#### 84. Выберите неверное утверждение о пакетах
>todo
#### 85. Ключ ```-classpath``` при запуске утилиты java используется для
>todo
#### 86. Ключ ```-d``` при запуске утилиты javac используется для
>todo
#### 87. Пакеты в Java подключаются с помощью директивы
>todo
#### 88. Перечисление имеет предопределенный метод
>todo
#### 89. Перечисление имеет предопределенный метод
>todo

## 12
#### 90. Выберите ложное утверждение об исключениях
>todo
#### 91. Выберите признак проверяемого исключения
>todo
#### 92. Выход за пределы индексации массива относится к типу исключения
>todo
#### 93. К классам исключений не относится
>todo
#### 94. К основным методам класса ```Throwable``` не относится
>todo
#### 95. Ошибка деления на ноль относится к классу исключения
>todo
#### 96. Ошибка доступа к файлу относится к классу исключения
>todo

## 13
#### 97. Знак «*» в регулярном выражении означает
>todo
#### 98. Знак «.» в регулярном выражении означает
>todo
#### 99. Квантификаторы нужны для
>todo
#### 100. Круглые скобки в регулярном выражении служат для
>todo
#### 101. Символьный класс определяет
>todo
#### 102. Укажите, какая строки будут соответствовать указанному регулярному выражению 
```javascript
[a-zA-Z]{1}[a-zA-Z\\d\\.\\_]+@([a-zA-Z]+\\.){1,2}((net)|(com)|(org))
```
>todo

## 14
#### 103. Восстановление объекта при сериализации производится
>todo
#### 104. Выберите истинное утверждение о сериализации
>todo
#### 105. Для указания того, что во время сериализации объекта некоторое поле нужно игнорировать, используется модификатор
>todo
#### 106. К несериализуемому системному типу относится
>todo
#### 107. К сериализуемым системным типам относится
>todo
#### 108. Необходимым условием для сериализации объектов класса является
>todo
#### 109. Сериализация — это
>todo
#### 110. Сохранение объекта при сериализации производится
>todo

## 15
#### 111. К методам, общим для всех объектов не относится
>todo
#### 112. Функция ```clone()```
>todo
#### 113. Функция ```compareTo()```
>todo
#### 114. Функция ```equals()```
>todo
#### 115. Функция ```hashCode()```
>todo
#### 116. Функция ```toString()```
>todo

## 16
#### 117. Выберите истинное высказывание
>todo
#### 118. Выберите корректный пример отношения композиции
>todo
#### 119. Выберите ложное высказывание о спецификации абстрактного класса в UML
>todo
#### 120. Выберите ложное высказывание о спецификации интерфейса в UML
>todo
#### 121. Для обозначение статических атрибутов и операций в UML используется
>todo
#### 122. Для обозначения абстрактного класса его имя и абстрактные функции
>todo
#### 123. Для обозначения отношения обобщения в языке UML используется
>todo
#### 124. Для обозначения реализации интерфейса в языке UML используется
>todo
#### 125. Зависимость – это…
>todo
#### 126. Постусловие операции это
>todo

## 17
#### 127. Антипаттерн – это
>todo
#### 128. Выберите метод, являющийся методом рефакторинга
>todo
#### 129. К принципам Grasp не относится
>todo
#### 130. Принцип "Open-Closed" гласит
>todo
#### 131. Принцип "The Dependency Inversion Principle" гласит
>todo
#### 132. Принцип "The Single Responsibility Principle" гласит
>todo
#### 133. Рефакторинг направлен на
>todo

## 18
#### 134. К поведенческим паттернам относится паттерн
*Цепочка обязанностей
*Команда
*Итератор
*Посредник
*Снимок
*Наблюдатель
*Состояние
*Стратегия
*Шаблонный метод
*Посетитель
#### 135. К порождающим паттернам проектирования не относится
**Поведенческие
*Цепочка обязанностей
*Команда
*Итератор
*Посредник
*Снимок
*Наблюдатель
*Состояние
*Стратегия
*Шаблонный метод
*Посетитель
**Структурные
*Адаптер
*Мост
*Компоновщик
*Декоратор
*Фасад
*Легковес
*Заместитель
#### 136. К структурным паттернам относится паттерн
*Адаптер
*Мост
*Компоновщик
*Декоратор
*Фасад
*Легковес
*Заместитель
#### 137. Паттерн Абстрактная Фабрика
Порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, 
не привязываясь к конкретным классам создаваемых объектов.
#### 144. Паттерн Одиночка
Порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, 
и предоставляет к нему глобальную точку доступа.
#### 147. Паттерн Строитель
Порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. 
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
#### 148. Паттерн Фабрика
Порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, 
позволяя подклассам изменять тип создаваемых объектов.
#### 138. Паттерн Адаптор
Структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.
#### 139. Паттерн Декоратор
Структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, 
оборачивая их в полезные «обёртки».
#### 142. Паттерн Компоновщик
Структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, 
а затем работать с ней так, как будто это единичный объект.
#### 143. Паттерн Мост
Структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, 
позволяя изменять их независимо друг от друга.
#### 140. Паттерн Итератор
Поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, 
не раскрывая их внутреннего представления.
#### 141. Паттерн Команда
Поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, 
ставить запросы в очередь, логировать их, а также поддерживать отмену операций.
#### 145. Паттерн Состояние
Поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. 
Извне создаётся впечатление, что изменился класс объекта.
#### 146. Паттерн Стратегия
Поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, 
после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

## 19
#### 149. Выберите истинное высказывание относительно ограничений на обобщенные типы
- Нельзя создавать экземпляры обобщённых типов с примитивными типами в качестве аргументов типа.
- Нельзя создавать экземпляры параметров типа
- Нельзя объявлять статические поля с типом параметра типа
- Нельзя использовать приведения типа или instanceof с параметризованными типами
- Невозможно создавать массивы параметризованных типов
- Нельзя создавать, ловить (catch) или бросать (throw) объекты параметризованных типов
- Нельзя перегружать метод так, чтобы формальные параметры типа стирались в один и тот же сырой тип
#### 150. Выберите ложное высказывание относительно ограничений на обобщенные типы
Все что не входит в вопрос выше
#### 151. Метасимвольный аргумент
Обозначается знаком ? и представляет неизвестный тип.
```Java
boolean sameAvg(Average<?> ob) {
    return average() == ob.average();
}
```
Метасимвол не оказывает никакого влияния на тип создаваемых объектов класса Average. 
Это определяется оператором extends в объявлении класса Average. 
Метасимвол просто совпадает c любым достоверным объектом класса Average.
#### 152. Обобщенные типы задаются с помощью
С помощью буквы T в определении класса class Account<T> мы указываем, что данный тип T будет использоваться этим классом. 
Параметр T в угловых скобках называется универсальным параметром, так как вместо него можно подставить любой тип. 
При этом пока мы не знаем, какой именно это будет тип: String, int или какой-то другой. 
Причем буква T выбрана условна, это может и любая другая буква или набор символов.
#### 153. Ограничение на метасимвольный аргумент, заданное с помощью ключевого слова ```extends```
В целом верхняя граница для метасимвольного аргумента задается в следующей общей форме:
```Java
<? extends суперкласс >
```
где после ключевого слова extends указывается суперкласс, т.е. имя класса, определяющего верхнюю границу, включая и его самого. 
Это означает, что в качестве аргумента допускается указывать не только подклассы данного класса, но и сам этот класс.
Ограниченные типы оказываются особенно полезными в тех случаях, когда нужно обеспечить совместимость одного параметра типа с другим.
#### 154. Ограничение на метасимвольный аргумент, заданное с помощью ключевого слова ```super```
По мере необходимости можно также указать нижнюю границу для метасимвольного аргумента. 
Для этой цели служит ключевое слово super, указываемое в следующей общей форме:
```Java
<? extends подкласс >
```
В данном случае в качестве аргумента допускается использовать только суперклассы, от которых наследует подкласс, исключая его самого. 
Это означает, что подкласс, определяющий нижнюю границу, не относится к числу классов, передаваемых в качестве аргумента.
#### 155. При использовании generic типов
Существует возможность создавать более статически типизированный код. 
Соответственно, программы становятся более надежными и проще в отладке.
Свойства Generics
**Строгая типизация.
**Единая реализация.
**Отсутствие информации о типе.
#### 156. При использовании non-generic типов
Теряется преимущество безопасности типов, предоставляемое дженериками
Generics не дадут скомпилировать код с ошибкой, а у простого типа мы сможем заметить ошибку уже во время работы приложения.

## 20
#### 157. Базовая концепция Java — Collection — является
>todo
#### 158. В какую иерархию коллекций входит ```Map```
>todo
#### 159. Выберите операцию, которая не является общей для разных типов коллекций
>todo
#### 160. Итератор — это
>todo
#### 161. К коллекции, специально созданной для работы в многопоточном режиме, относится
>todo
#### 162. Коллекция типа ```List``` — это
>todo
#### 163. Коллекция типа ```Map``` — это
>todo
#### 164. Коллекция типа ```Queue``` — это
>todo
#### 165. Коллекция типа ```Set``` — это
>todo
#### 166. Основные типы коллекций находятся в пакете
>todo

## 21
#### 167. ```List``` в Java является
>todo
#### 168. Интерфейс ```List``` не содержит описание следующего метода
>todo
#### 169. К основным реализациям ```List``` не относится
>todo
#### 170. Контейнер типа ```ArrayList``` представляет собой
>todo
#### 171. Контейнер типа ```LinkedList``` представляет собой
>todo
#### 172. Одна из особенностей ```ListIterator``` по сравнению с обычным ```Iterator``` в том
>todo

## 22
#### 173. ```Map``` в Java является
>todo
#### 174. Взаимодействие потоков может осуществляться с помощью функции
>todo
#### 175. Выберите ложное утверждение о многопоточном программировании
>todo
#### 176. Выберите ложное утверждение о множествах (```Set```)
>todo
#### 177. Выберите ложное утверждение об отображениях (```Map```)
>todo
#### 178. Главная особенность реализаций ```SortedSet``` в
>todo
#### 179. Интерфейс ```Comparable``` предназначен для
>todo
#### 180. Интерфейс ```Map``` не содержит описание следующего метода
>todo
#### 181. Итерация по отображению
>todo
#### 182. К основным реализациям ```Set``` не относится
>todo
#### 183. К отображению, которое сохраняет элементы в отсортированном порядке относится
>todo
#### 184. К преимуществам многопоточности не относится
>todo
#### 185. К состояниям потока не относится
>todo
#### 186. Компараторы позволяют
>todo
#### 187. Почему ```Map``` не расширяет интерфейс ```Collection```?
>todo

## 23
#### 188. Test-Driven Development — это
>todo
#### 189. Библиотека JUnit применяется для
>todo
#### 190. Выберите истинное утверждение
>todo
#### 191. Выберите ложное утверждение
>todo
#### 192. Исчерпывающее тестирование (входное или тестирование путей)
>todo
#### 193. Не существует стратегии тестирования методом
>todo
#### 194. Тестирование – это
>todo
#### 195. Тестирование методом белого ящика предполагает, что
>todo
#### 196. Тестирование методом черного ящика предполагает, что
>todo

## 24
#### 197. К методам тестирования "белого ящика" не относятся
>todo
#### 198. К методам тестирования "черного ящика" не относится
>todo
#### 199. Тестирование методом анализа граничных значений
>todo
#### 200. Тестирование методом комбинаторного покрытия условий
>todo
#### 201. Тестирование методом покрытия операторов
>todo
#### 202. Тестирование методом покрытия решений
>todo
#### 203. Тестирование методом покрытия условий
>todo
#### 204. Тестирование методом эквивалентного разбиения
>todo

## 25
#### 205. Инкрементное тестирование – это
>todo
#### 206. К достоинствам восходящего тестирования относится
>todo
#### 207. К достоинствам нисходящего тестирования относится
>todo
#### 208. К недостаткам восходящего тестирования относится
>todo
#### 209. К недостаткам нисходящего тестирования относится
>todo
#### 210. Модульное тестирование – это
>todo
#### 211. Неинкрементное тестирование – это
>todo

## 26
#### 212. Категория "Возможности" в системном тесте предполагает
>todo
#### 213. Категория "Восстанавливаемости" в системном тесте предполагает
>todo
#### 214. Категория "Надежности" в системном тесте предполагает
>todo
#### 215. Цель интеграционного теста
>todo
#### 216. Цель модульного теста
>todo
#### 217. Цель приемочного теста
>todo
#### 218. Цель системного теста
>todo
#### 219. Цель тестирования установки
>todo
#### 220. Цель функционального теста
>todo

## 27
#### 221. Аппендер - это объект, который определяет
>todo
#### 222. Библиотека log4j используется для
>todo
#### 223. Инварианты класса – это
>todo
#### 224. Методика проектирования по контракту
>todo
#### 225. Механизм утверждений (assertions) используется в Java для проверки
>todo
#### 226. Наивысший приоритет в log4j имеют сообщения с уровнем
>todo
#### 227. Наивысший приоритет среди представленных в log4j имеют сообщения с уровнем
>todo
#### 228. Наинизший приоритет в log4j имеют сообщения с уровнем
>todo
#### 229. Наинизший приоритет среди представленных в log4j имеют сообщения с уровнем
>todo
#### 230. Постусловия – это
>todo
#### 231. Предусловия - это
>todo
#### 232. Условная компиляция в Java позволяет
>todo
#### 233. Форматер нужен для определения
>todo

## 28
#### 234. Объект, представляющий собой окно программы и содержащий все объекты JavaFX-приложения называется
>todo
#### 235. Объект, представляющий физический контент JavaFX-приложения называется
>todo
#### 236. Основным паттерном, используемым при разработке JavaFX-приложения, является
>todo
#### 237. Разметка JavaFX-приложения хранится в файле с расширением
>todo
#### 238. Макет JavaFX, размещающий все компоненты приложения последовательно друг на друге, называется
>todo
#### 239. Макет JavaFX, добавляющий компоненты приложения в форме плиток одинакового размера, называется
>todo
#### 240. Одновременные манипуляции, выполняемые несколькими потоками, над графом сцены JavaFX
>todo
#### 241. Классы, применяемые для организации многопоточности в JavaFX, называются
>todo

## 29
#### 242. Этот интерфейс применяется при использовании статических SQL-запросов, не изменяющихся в процессе работы
>todo
#### 243. Этот интерфейс применяется, если SQL-запросы используют параметры, которые многократно изменяются в процессе работы
>todo
#### 244. Метод ```Statement```, возвращающий ```ResultSet```-объект, называется
>todo
#### 245. Интерфейс ```CallableStatement``` применяется для
>todo
#### 246. С помощью этого интерфейса можно получить доступ к данным, полученным оператором ```SELECT```
>todo
#### 247. По выборке, получаемой с помощью объекта ```ResultSet```, можно двигаться
>todo
#### 248. Выборка, получаемая с помощью ```ResultSet``` является
>todo
#### 249. Ключевая особенность транзакций -
>todo
#### 250. Типы данных JDBC
>todo
#### 251. Для закрепления изменений, произведенных транзакцией
>todo
#### 252. Для включения режима транзакций при наличии объекта ```Connection conn``` используется
>todo
#### 253. Для внесения изменений в таблицу базы данных
>todo

## 30
#### 254. При использовании ссылок на методы можно ссылаться на
>todo
#### 255. Функция является чистой, если
>todo
#### 256. Функция имеет высший порядок, если
>todo
#### 257. Функция не изменяет состояние, если
>todo
#### 258. Функциональный интерфейс — это
>todo
#### 259. Для сопоставления лямбда-выражения и интерфейса необходимо
>todo
#### 260. К встроенным функциональным интерфейсам Java не относится
>todo
#### 261. Функциональный интерфейс, представляющий функцию, принимающий один параметр и возвращающий единственное значение, это (выбрать наиболее подходящий)
>todo
#### 262. Функциональный интерфейс, представляющий функцию, принимающий один параметр и возвращающий булево значение, это (выбрать наиболее подходящий)
>todo
#### 263. Функциональный интерфейс, представляющий функцию, принимающий один параметр и возвращающий значение того же типа, это  (выбрать наиболее подходящий)
>todo
#### 264. ```Consumer``` — это функциональный интерфейс, представляющий функцию, которая
>todo
#### 265. Техника, которая комбинирует множественные функции в единую функцию, которая использует все комбинируемые функции, это
>todo
#### 266. Функциональная композиция предикатов может выполняться
>todo
#### 267. Функциональная композиция функций может выполняться
>todo
#### 268. Что такое Java Stream API
>todo
#### 269. Нетерминальная потоковая операция это
>todo
#### 270. Терминальная потоковая операция это
>todo
#### 271. К терминальным потоковым операциям не относится метод
>todo
#### 272. К терминальным потоковым операциям относится метод
>todo
#### 273. К нетерминальным потоковым операциям не относится метод
>todo
#### 274. К нетерминальным потоковым операциям относится метод
>todo
#### 275. К недостаткам Java Stream API относится
>todo