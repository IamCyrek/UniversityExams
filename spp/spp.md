## 1
#### 1. Just-In-Time-компилятор позволяет
JIT-компиляция (англ. Just-in-time compilation, компиляция «на лету»), динамическая компиляция (англ. dynamic translation) — технология увеличения производительности программных систем, использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы. 
#### 2. Для разработки программ на языке Java необходима установка
JDK
#### 3. Запуск Java-программы производится
Чтобы запустить программу, нужно ввести команду java с именем класса (не файла!) в качестве параметра:

```java Main```

И чтобы запустить программу с аргументами, пишем в консоль:

```java Main arg0 arg1 arg2```
#### 4. Использование языковой виртуальной машины позволяет добиться
Кроссплатформенности
#### 5. Компиляция исходного кода производится
Для того, чтобы скомпилировать файл нужно набрать в консоли команду javac и в качестве параметра передать имя нашего файла. 
Например, 	

```javac Main.java```

Эта команда вызовет компилятор, который создаст файл Main.class, содержащий скомпилированный код нашей java программы.
#### 6. Особенностью языка программирования Java является
- Отсутствие множественного наследования
- Интерфейсы
- Перечисления
- Поддержка механизма обработки исключений
- Обобщенные (generics) классы
- Аннотации
- Средства параллельного программирования
- Поддержка лямбда-выражений (начиная с 8 в.)
#### 7. Пакеты служат для
Пакет (package) — это некий контейнер, который используется для того, чтобы изолировать имена классов. Например, вы можете создать класс List, заключить его в пакет и не думать после этого о возможных конфликтах, которые могли бы возникнуть если бы кто-нибудь еще создал класс с именем List. 
Пакеты — это механизм, который служит как для работы с пространством имен, так и для ограничения видимости. 
#### 8. Сигнатура функции ```main``` имеет вид
- ```main(String[] args)``` - сигнатура
- ```public static void main(String[] args)``` - объявление
#### 9. Синтаксис языка программирования Java схож с синтаксисом языка
C#
#### 10. Структурными частями простейшего Java-проекта являются
Структура простейшего проекта в IntelliJ IDEA:
- папка .idea c конфигурационными xml файлами
- папка src в которой находятся Java-классы, один из которые содержит функцию main. 
- файл .iml

Структура проекта:
- src - исходный код
- lib - библиотеки
- res - прочие ресурсы
- test - исходный код тестов
#### 11. Точкой входа в любую Java-программу является
```main(String[] args)```
#### 12. Язык программирования Java является
- Языком высокого уровня
- Императивным
- Со строгой статической типизацией
- Объектно-ориентированный

## 2
#### 13. В выражении, содержащем переменные типа ```byte, short, char``` происходит автоматическое повышение типа до
int
#### 14. В выражении, содержащем переменные типа ```double``` и ```long```, происходит автоматическое повышение типа до
double
#### 15. В выражении, содержащем переменные типа ```float``` и ```double```, происходит автоматическое повышение типа до
double
#### 16. В выражении, содержащем переменные типа ```float```, происходит автоматическое повышение типа до
float
#### 17. В выражении, содержащем переменные типа ```int``` и ```long```, происходит автоматическое повышение типа до
long
#### 18. К классам-оберткам над элементарными типами данных не относится
Относится: Double, Float, Long, Integer, Short, Byte, Character и Boolean
#### 19. К типам с плавающей запятой относится тип
float, double
#### 20. К целочисленным типам данных Java не относится тип
Относится: long, int, short, byte

## 3
#### 21. В Java ссылки всегда передаются
объекты
#### 22. Значение ```null``` используется в Java
значение по умолчанию для ссылочных типов
#### 23. Объект может быть передан по ссылке
передается по ссылке, но не влияет на сам объект
#### 24. Объект называется достижимым, если
если на него ссылается другой достижимый объект. 
#### 25. Преобразование типа переменной подкласса к типу суперкласса
происходит автоматически
#### 26. Преобразование типа переменной суперкласса к типу подкласса
требует явного преобразования
#### 27. Приведение ссылочных типов возможно
если классы в одной иерархии
#### 28. Прямое присваивание одной ссылке значения другой ссылки приведет к тому
переприсваивание ссылки

## 4
#### 29. Для представления символов в Java используется кодировка
UTF-16
Из лекции: Для представления символов используется кодировка Unicode.
#### 30. Изменение отдельного символа строки
невозможно, если не использовать StringBuilder
#### 31. Получение отдельного символа строки
String.charAt()
#### 32. При именовании переменных в Java не допускаются
ключевые или зарезервированные слова, пробелы, не начинать с цифр,
Может состоять из букв (Unicode), цифр и символа подчеркивания «_». 
#### 33. Строковые литералы в Java являются
набор символов в двойных кавычках
#### 34. Тип ```char``` относится к
примитивным типам
Из лекции: char – формально целочисленный, но используется только для хранения символов.
#### 35. У переменных типа ```String``` нет встроенных функций, поддерживающих следующую операцию над строками
основные методы
- concat(): объединяет строки
- valueOf(): преобразует объект в строковый вид
- join(): соединяет строки с учетом разделителя
- сompare(): сравнивает две строки
- charAt(): возвращает символ строки по индексу
- getChars(): возвращает группу символов
- equals(): сравнивает строки с учетом регистра
- equalsIgnoreCase(): сравнивает строки без учета регистра
- regionMatches(): сравнивает подстроки в строках
- indexOf(): находит индекс первого вхождения подстроки в строку
- lastIndexOf(): находит индекс последнего вхождения подстроки в строку
- startsWith(): определяет, начинается ли строка с подстроки
- endsWith(): определяет, заканчивается ли строка на определенную подстроку
- replace(): заменяет в строке одну подстроку на другую
- trim(): удаляет начальные и конечные пробелы
- substring(): возвращает подстроку, начиная с определенного индекса до конца или до определенного индекса
- toLowerCase(): переводит все символы строки в нижний регистр
- toUpperCase(): переводит все символы строки в верхний регистр

## 5
#### 36. Выберите метод, не преобразующий строку
>todo
#### 37. Для какого потока не является необходимым вызов метода ```close```
>todo
#### 38. К стандартным потокам ввода-вывода Java не относится
>todo
#### 39. Пакет ```java.lang``` является
>todo
#### 40. Пакет ```java.util``` является
>todo
#### 41. Строка не может быть преобразована в число типа ```double``` применением
>todo
#### 42. Строка не может быть преобразована в число типа ```int``` применением
>todo

## 6
#### 43. Глубокое копирование массива объектов может быть достигнуто
>todo
#### 44. Глубокое копирование массива объектов — это…
>todo
#### 45. К основному недостатку массива по сравнению с коллекцией относят
>todo
#### 46. Коллекция — это…
>todo
#### 47. Основные типы коллекций в Java не включают
>todo

## 7
#### 48. В языке Java
>todo
#### 49. Выберите оператор, не являющийся оператором цикла
>todo
#### 50. Выберите оператор, являющийся оператором ветвления
>todo
#### 51. Выберите оператор, являющийся оператором перехода
>todo
#### 52. Оператор ```switch``` чаще всего используется
>todo
#### 53. Скомпилируется ли следующий код:
```Java
int i; int j; (false ? i: j) = 55;
```
>todo
#### 54. Цикл ```for``` в форме ```for each``` используется
>todo

## 8
#### 55. Выберите ложное высказывание относительно конструкторов в классах Java
>todo
#### 56. Выберите ложное высказывание относительно конструкторов в классах Java
>todo
#### 57. Для метода с одним параметром, которым является Java-объект, его поля будут передаваться
>todo
#### 58. Методы с модификатором ```final```
>todo
#### 59. Перегрузка методов — это
>todo
#### 60. Поле с модификатором ```final``` не может быть проинициализирована
>todo
#### 61. При перегрузке методов
>todo
#### 62. Статические методы и поля класса — это элементы…
>todo

## 9
#### 63. Анонимный класс — это
>todo
#### 64. Выберите ложное высказывание
>todo
#### 65. Выберите ложное высказывание о вложенных классах
>todo
#### 66. Для вызова метода суперкласса в классе-потомке (при наличии в классе-потомке одноименного метода) нужно
>todo
#### 67. Для переопределения метода в классе потомке достаточно
>todo
#### 68. Для указания того, что класс является подклассом используется
>todo
#### 69. Если в суперклассе есть один конструктор с параметрами, а в классе-потомке определен новый конструктор, не содержащий вызов конструктора суперкласса, то
>todo
#### 70. Ключевое слово ```super``` нельзя использовать
>todo
#### 71. Переопределение методов при наследовании позволяет
>todo

## 10
#### 72. В интерфейсе все поля являются по умолчанию
>todo
#### 73. В интерфейсе все функции являются по умолчанию
>todo
#### 74. Выберите ложное высказывание об абстрактных классах
>todo
#### 75. Выберите ложное высказывание об интерфейсах
>todo
#### 76. Динамическая диспетчеризация методов позволяет
>todo
#### 77. Для расширения интерфейса используется ключевое слово
>todo
#### 78. Для создания классов, которые не могут иметь потомков, применяется
>todo
#### 79. Для указания того, что класс реализует интерфейс используется
>todo
#### 80. Интерфейс — это
>todo
#### 81. Класс с модификатором ```final```
>todo

## 11
#### 82. Выберите ложное высказывание о перечислениях
>todo
#### 83. Выберите ложное высказывание о перечислениях
>todo
#### 84. Выберите неверное утверждение о пакетах
>todo
#### 85. Ключ ```-classpath``` при запуске утилиты java используется для
>todo
#### 86. Ключ ```-d``` при запуске утилиты javac используется для
>todo
#### 87. Пакеты в Java подключаются с помощью директивы
>todo
#### 88. Перечисление имеет предопределенный метод
>todo
#### 89. Перечисление имеет предопределенный метод
>todo

## 12
#### 90. Выберите ложное утверждение об исключениях
>todo
#### 91. Выберите признак проверяемого исключения
>todo
#### 92. Выход за пределы индексации массива относится к типу исключения
>todo
#### 93. К классам исключений не относится
>todo
#### 94. К основным методам класса ```Throwable``` не относится
>todo
#### 95. Ошибка деления на ноль относится к классу исключения
>todo
#### 96. Ошибка доступа к файлу относится к классу исключения
>todo

## 13
#### 97. Знак «*» в регулярном выражении означает
>todo
#### 98. Знак «.» в регулярном выражении означает
>todo
#### 99. Квантификаторы нужны для
>todo
#### 100. Круглые скобки в регулярном выражении служат для
>todo
#### 101. Символьный класс определяет
>todo
#### 102. Укажите, какая строки будут соответствовать указанному регулярному выражению 
```javascript
[a-zA-Z]{1}[a-zA-Z\\d\\.\\_]+@([a-zA-Z]+\\.){1,2}((net)|(com)|(org))
```
>todo

## 14
#### 103. Восстановление объекта при сериализации производится
>todo
#### 104. Выберите истинное утверждение о сериализации
>todo
#### 105. Для указания того, что во время сериализации объекта некоторое поле нужно игнорировать, используется модификатор
>todo
#### 106. К несериализуемому системному типу относится
>todo
#### 107. К сериализуемым системным типам относится
>todo
#### 108. Необходимым условием для сериализации объектов класса является
>todo
#### 109. Сериализация — это
>todo
#### 110. Сохранение объекта при сериализации производится
>todo

## 15
#### 111. К методам, общим для всех объектов не относится
У класса есть несколько важных методов.

- ```Object clone()``` - создаёт новый объект, не отличающий от клонируемого
- ```boolean equals(Object obj)``` - определяет, равен ли один объект другому
- ```void finalize()``` - вызывается перед удалением неиспользуемого объекта
- ```Class<?> getClass()``` - получает класс объекта во время выполнения
- ```int hashCode()``` - возвращает хеш-код, связанный с вызывающим объектом
- ```void notify()``` - возобновляет выполнение потока, который ожидает вызывающего объекта
- ```void notifyAll()``` - возобновляет выполнение всех потоков, которые ожидают вызывающего объекта
- ```String toString()``` - возвращает строку, описывающий объект
- ```void wait()``` - ожидает другого потока выполнения
- ```void wait(long millis)``` - ожидает другого потока выполнения
- ```void wait(long millis, int nanos)``` - ожидает другого потока выполнения

Методы getClass(), notify(), notifyAll(), wait() являются финальными и их нельзя переопределять.
#### 112. Функция ```clone()```
Cоздаёт новый объект, не отличающий от клонируемого. Находится в классе ```Object```. Объявлен как ```protected```. Реализует поверхностное клонироание.
#### 113. Функция ```compareTo()```
Метод ```compareTo``` в Java сравнивает вызывающий объект с объектом, переданным в качестве параметра, и возвращает в результате выполнения сравнения целое число:
- положительное, если вызывающий объект больше объекта, переданного в качестве параметра;
- отрицательное, если вызывающий объект меньше объекта, переданного в качестве параметра;
- нуль, если объекты равны.
Метод описан в интерфейсе Comparable. Используется при сортировках.
#### 114. Функция ```equals()```
Принадлежит классу ```Object```. По дефолту сравнивает ссылки ==. Необходимо переопределять для корректного сравнения. В ```String``` классе переопределен на корректное сравнение строк.
#### 115. Функция ```hashCode()```
Возвращает хеш-код, связанный с вызывающим объектом.
Хеш-код - это целое число, генерируемое на основе конкретного объекта.
Его можно рассматривать как шифр с уникальным значением.
У любого объекта имется хеш-код, определяемый по умолчанию, который вычисляется по адресу памяти, занимаемой объектом.
Значение хеш-кода возвращает целочисленное значение, в том числ и отрицательное.
Если в вашем классе переопределяется метод ```equals()```, то следует переопределить и метод ```hashCode()```.
#### 116. Функция ```toString()```
Возвращает строку, описывающий объект.

Очень часто при использовании метода ```toString()``` для получения описания объекта можно получить набор бессмысленных символов, например, [I@421199e8.
На самом деле в них есть смысл, доступный специалистом. Он сразу может сказать, что мы имеем дело с одномерным массивом (одна квадратная скобка), который имеет тип int (символ I).

Обычно принято переопределять метод, чтобы он выводил результат в читаемом виде.

## 16
#### 117. Выберите истинное высказывание
Выбрал
#### 118. Выберите корректный пример отношения композиции
Разновидность отношения агрегации, при которой составные части целого имеют такое же время жизни, что и само целое. 

Это отношение служит для выделения специальной формы отношения «часть-целое».
Графически отношение композиции изображается сплошной линией,
один из концов которой представляет собой закрашенный внутри ромб.
Этот ромб указывает на тот из классов, который представляет собой класс-композицию или «целое».
#### 119. Выберите ложное высказывание о спецификации абстрактного класса в UML
Название абстрактного классификатора показано курсивом, где разрешено используемым шрифтом.
В качестве альтернативы или, кроме того, абстрактный классификатор может быть показан с использованием текстовой аннотации {abstract} после или под ее именем.
#### 120. Выберите ложное высказывание о спецификации интерфейса в UML
Интерфейс (interface) служит для спецификации параметров модели, которые видимы извне без указания их внутренней структуры. В языке UML интерфейс является классификатором и характеризует только ограниченную часть поведения моделируемой сущности. Применительно к диаграммам вариантов использования, интерфейсы определяют совокупность операций, которые обеспечивают необходимый набор сервисов или функциональности для актеров. Интерфейсы не могут содержать ни атрибутов, ни состояний, ни направленных ассоциаций. Они содержат только операции без указания особенностей их реализации. Формально интерфейс эквивалентен абстрактному классу без атрибутов и методов с наличием только абстрактных операций.

На диаграмме вариантов использования интерфейс изображается в виде маленького круга, рядом с которым записывается его имя.
Кроме этого, интерфейсы могут соединяться с вариантами использования пунктирной линией со стрелкой/сплошной бз стрелки.
#### 121. Для обозначение статических атрибутов и операций в UML используется
Нижнее сплошное подчеркивание
#### 122. Для обозначения абстрактного класса его имя и абстрактные функции
Используется курсив
#### 123. Для обозначения отношения обобщения в языке UML используется
Сплошная линия с треугольной стрелкой на одном из концов. Стрелка указывает на более общий класс.
#### 124. Для обозначения реализации интерфейса в языке UML используется
Если класс реализует интерфейс - слошная линия с кружком(интерфейсом). Если требует интерфейс - то значок "гнездо" и пунктирная линия.
#### 125. Зависимость – это…
Зависимость обозначает такое отношение между классами, что изменение спецификации класса-поставщика может повлиять на работу зависимого класса, но не наоборот.
#### 126. Постусловие операции это
Условие, которое должно быть истинным, когда вызов операции успешно завершился, в предположении, что все предусловия были удовлетворены.

## 17
#### 127. Антипаттерн – это
Антипаттерн — это распространённый подход к решению класса часто встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным.
#### 128. Выберите метод, являющийся методом рефакторинга
Наиболее употребимые методы рефакторинга:
- Изменение сигнатуры метода (change method signature)
- Инкапсуляция поля (encapsulate field)
- Выделение класса (extract class)
- Выделение интерфейса (extract interface)
- Выделение локальной переменной (extract local variable)
- Выделение метода (extract method)
- Генерализация типа (generalize type)
- Встраивание (inline)
- Введение фабрики (introduce factory)
- Введение параметра (introduce parameter)
- Подъём метода (pull up method)
- Спуск метода (push down method)
- Переименование метода (rename method)
- Перемещение метода (move method)
- Замена условного оператора полиморфизмом (replace conditional with polymorphism)
- Замена наследования делегированием (replace inheritance with delegation)
- Замена кода типа подклассами (replace type code with subclasses)
- Замена кода стек в рекурсию и обратно
#### 129. К принципам Grasp не относится
GRASP выделяет следующие принципы-шаблоны: 
- Information Expert (Информационные эксперт)
- Creator (Создатель)
- Controller (Контроллер)
- Low Coupling (Слабая связанность)
- High Cohesion (Высокая сцепленность)
- Pure Fabrication (Чистая выдумка или чистое синтезирование)
- Indirection (Посредник)
- Protected Variations (Сокрытие реализации или защищенные изменения)
- Polymorphism (Полиморфизм)
#### 130. Принцип "Open-Closed" гласит
Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения
#### 131. Принцип "The Dependency Inversion Principle" гласит
Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
#### 132. Принцип "The Single Responsibility Principle" гласит
каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс.
Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.
#### 133. Рефакторинг направлен на
Цель рефакторинга — сделать код программы более легким для понимания; без этого рефакторинг нельзя считать успешным.

## 18
#### 134. К поведенческим паттернам относится паттерн
- Цепочка обязанностей
- Команда
- Итератор
- Посредник
- Снимок
- Наблюдатель
- Состояние
- Стратегия
- Шаблонный метод
- Посетитель
#### 135. К порождающим паттернам проектирования не относится
**Поведенческие**
- Цепочка обязанностей
- Команда
- Итератор
- Посредник
- Снимок
- Наблюдатель
- Состояние
- Стратегия
- Шаблонный метод
- Посетитель

**Структурные**
- Адаптер
- Мост
- Компоновщик
- Декоратор
- Фасад
- Легковес
- Заместитель
#### 136. К структурным паттернам относится паттерн
- Адаптер
- Мост
- Компоновщик
- Декоратор
- Фасад
- Легковес
- Заместитель
#### 137. Паттерн Абстрактная Фабрика
Порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, 
не привязываясь к конкретным классам создаваемых объектов.
#### 144. Паттерн Одиночка
Порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, 
и предоставляет к нему глобальную точку доступа.
#### 147. Паттерн Строитель
Порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. 
Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
#### 148. Паттерн Фабрика
Порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, 
позволяя подклассам изменять тип создаваемых объектов.
#### 138. Паттерн Адаптор
Структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.
#### 139. Паттерн Декоратор
Структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, 
оборачивая их в полезные «обёртки».
#### 142. Паттерн Компоновщик
Структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, 
а затем работать с ней так, как будто это единичный объект.
#### 143. Паттерн Мост
Структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, 
позволяя изменять их независимо друг от друга.
#### 140. Паттерн Итератор
Поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, 
не раскрывая их внутреннего представления.
#### 141. Паттерн Команда
Поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, 
ставить запросы в очередь, логировать их, а также поддерживать отмену операций.
#### 145. Паттерн Состояние
Поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. 
Извне создаётся впечатление, что изменился класс объекта.
#### 146. Паттерн Стратегия
Поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, 
после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

## 19
#### 149. Выберите истинное высказывание относительно ограничений на обобщенные типы
- Нельзя создавать экземпляры обобщённых типов с примитивными типами в качестве аргументов типа.
- Нельзя создавать экземпляры параметров типа
- Нельзя объявлять статические поля с типом параметра типа
- Нельзя использовать приведения типа или ```instanceof``` с параметризованными типами
- Невозможно создавать массивы параметризованных типов
- Нельзя создавать, ловить (catch) или бросать (throw) объекты параметризованных типов
- Нельзя перегружать метод так, чтобы формальные параметры типа стирались в один и тот же сырой тип
#### 150. Выберите ложное высказывание относительно ограничений на обобщенные типы
Все что не входит в вопрос выше
#### 151. Метасимвольный аргумент
Обозначается знаком ? и представляет неизвестный тип.
```Java
boolean sameAvg(Average<?> ob) {
    return average() == ob.average();
}
```
Метасимвол не оказывает никакого влияния на тип создаваемых объектов класса Average. 
Это определяется оператором extends в объявлении класса Average. 
Метасимвол просто совпадает c любым достоверным объектом класса Average.
#### 152. Обобщенные типы задаются с помощью
С помощью буквы T в определении класса ```class Account<T>``` мы указываем, что данный тип T будет использоваться этим классом. 
Параметр T в угловых скобках называется универсальным параметром, так как вместо него можно подставить любой тип. 
При этом пока мы не знаем, какой именно это будет тип: String, int или какой-то другой. 
Причем буква T выбрана условна, это может и любая другая буква или набор символов.
#### 153. Ограничение на метасимвольный аргумент, заданное с помощью ключевого слова ```extends```
В целом верхняя граница для метасимвольного аргумента задается в следующей общей форме:
```Java
<? extends суперкласс >
```
где после ключевого слова extends указывается суперкласс, т.е. имя класса, определяющего верхнюю границу, включая и его самого. 
Это означает, что в качестве аргумента допускается указывать не только подклассы данного класса, но и сам этот класс.
Ограниченные типы оказываются особенно полезными в тех случаях, когда нужно обеспечить совместимость одного параметра типа с другим.
#### 154. Ограничение на метасимвольный аргумент, заданное с помощью ключевого слова ```super```
По мере необходимости можно также указать нижнюю границу для метасимвольного аргумента. 
Для этой цели служит ключевое слово super, указываемое в следующей общей форме:
```Java
<? extends подкласс >
```
В данном случае в качестве аргумента допускается использовать только суперклассы, от которых наследует подкласс, исключая его самого. 
Это означает, что подкласс, определяющий нижнюю границу, не относится к числу классов, передаваемых в качестве аргумента.
#### 155. При использовании generic типов
Существует возможность создавать более статически типизированный код. 
Соответственно, программы становятся более надежными и проще в отладке.
Свойства Generics
- Строгая типизация.
- Единая реализация.
- Отсутствие информации о типе.
#### 156. При использовании non-generic типов
Теряется преимущество безопасности типов, предоставляемое дженериками
Generics не дадут скомпилировать код с ошибкой, а у простого типа мы сможем заметить ошибку уже во время работы приложения.

## 20
#### 157. Базовая концепция Java — Collection — является
Базовым интерфейсом для всех коллекций и других интерфейсов коллекций. 
Определяет основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (например size(), isEmpty(), add(E e) и др.).
#### 158. В какую иерархию коллекций входит ```Map```
Представляет отдельную коллекцию.
#### 159. Выберите операцию, которая не является общей для разных типов коллекций
**ОБЩИЕ МЕТОДЫ:** ```add, addAll, clear, contains, isEmpty, iterator, remove, removeAll, retainAll, size, toArray.```
#### 160. Итератор — это
Объект, возвращаемый методом **iterator()**.
Используется для построения объектов, которые обеспечивают доступ к элементам коллекции.
Такой объект позволяет просматривать содержимое коллекции последовательно, элемент за элементом.
#### 161. К коллекции, специально созданной для работы в многопоточном режиме, относится
**Очередь(Queue)**
#### 162. Коллекция типа ```List``` — это
Упорядоченная коллекция, в которой допустимы дублирующие значения и она представляет функциональность простых списков. 
Иногда их называют последовательностями (sequence). 
Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу.
#### 163. Коллекция типа ```Map``` — это
Коллекция, состоящая из пар "ключ — значение". У каждого ключа только одно значение.
В отличие от других интерфейсов коллекций не наследуется от интерфейса Collection.
#### 164. Коллекция типа ```Queue``` — это
Коллекция, предназначенная для хранения элементов в порядке, нужном для их обработки. 
В дополнение к базовым операциям интерфейса Collection, очередь предоставляет дополнительные операции вставки, получения и контроля.
#### 165. Коллекция типа ```Set``` — это
Неупорядоченная коллекция, не содержащая повторяющихся элементов. Это соответствует математическому понятию множества.
#### 166. Основные типы коллекций находятся в пакете
```java.util```

## 21
#### 167. ```List``` в Java является
Интерфейсом для операций с коллекцией, которая является списком.
#### 168. Интерфейс ```List``` не содержит описание следующего метода
**СОДЕРЖИТ:** ```add, addAll, get, indexOf, lastIndexOf, listiterator(), remove, set, sort, subList.```
#### 169. К основным реализациям ```List``` не относится
**ОТНОСИТСЯ:** ```ArrayList, LinkedList, Vector, Stack.```
#### 170. Контейнер типа ```ArrayList``` представляет собой
Простой список объектов, т.е. инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов.
#### 171. Контейнер типа ```LinkedList``` представляет собой
Связанный список, т.е. структура данных, состоящая из узлов, каждый из которых содержит как собственно данные, так и  две ссылки на следующий и предыдущий узел списка.
#### 172. Одна из особенностей ```ListIterator``` по сравнению с обычным ```Iterator``` в том
- ```Iterator``` может использоваться для перебора элементов ```Set, List и Map```. В отличие от него, ```ListIterator``` может быть использован только для перебора элементов коллекции List.
- ```Iterator``` позволяет перебирать элементы только в одном направлении, при помощи метода ```next()```. Тогда как ```ListIterator``` позволяет перебирать список в обоих направлениях, при помощи методов ```next()``` и ```previous()```.
- При помощи ```ListIterator``` вы можете модифицировать список, добавляя/удаляя элементы с помощью методов ```add()``` и ```remove()```. ```Iterator``` не поддерживает данного функционала.

## 22
#### 173. ```Map``` в Java является
>todo
#### 174. Взаимодействие потоков может осуществляться с помощью функции
>todo
#### 175. Выберите ложное утверждение о многопоточном программировании
>todo
#### 176. Выберите ложное утверждение о множествах (```Set```)
>todo
#### 177. Выберите ложное утверждение об отображениях (```Map```)
>todo
#### 178. Главная особенность реализаций ```SortedSet``` в
>todo
#### 179. Интерфейс ```Comparable``` предназначен для
>todo
#### 180. Интерфейс ```Map``` не содержит описание следующего метода
>todo
#### 181. Итерация по отображению
>todo
#### 182. К основным реализациям ```Set``` не относится
>todo
#### 183. К отображению, которое сохраняет элементы в отсортированном порядке относится
>todo
#### 184. К преимуществам многопоточности не относится
>todo
#### 185. К состояниям потока не относится
>todo
#### 186. Компараторы позволяют
>todo
#### 187. Почему ```Map``` не расширяет интерфейс ```Collection```?
>todo

## 23
#### 188. Test-Driven Development — это
>todo
#### 189. Библиотека JUnit применяется для
>todo
#### 190. Выберите истинное утверждение
>todo
#### 191. Выберите ложное утверждение
>todo
#### 192. Исчерпывающее тестирование (входное или тестирование путей)
>todo
#### 193. Не существует стратегии тестирования методом
>todo
#### 194. Тестирование – это
>todo
#### 195. Тестирование методом белого ящика предполагает, что
>todo
#### 196. Тестирование методом черного ящика предполагает, что
>todo

## 24
#### 197. К методам тестирования "белого ящика" не относятся
>todo
#### 198. К методам тестирования "черного ящика" не относится
>todo
#### 199. Тестирование методом анализа граничных значений
>todo
#### 200. Тестирование методом комбинаторного покрытия условий
>todo
#### 201. Тестирование методом покрытия операторов
>todo
#### 202. Тестирование методом покрытия решений
>todo
#### 203. Тестирование методом покрытия условий
>todo
#### 204. Тестирование методом эквивалентного разбиения
>todo

## 25
#### 205. Инкрементное тестирование – это
>todo
#### 206. К достоинствам восходящего тестирования относится
>todo
#### 207. К достоинствам нисходящего тестирования относится
>todo
#### 208. К недостаткам восходящего тестирования относится
>todo
#### 209. К недостаткам нисходящего тестирования относится
>todo
#### 210. Модульное тестирование – это
>todo
#### 211. Неинкрементное тестирование – это
>todo

## 26
#### 212. Категория "Возможности" в системном тесте предполагает
>todo
#### 213. Категория "Восстанавливаемости" в системном тесте предполагает
>todo
#### 214. Категория "Надежности" в системном тесте предполагает
>todo
#### 215. Цель интеграционного теста
>todo
#### 216. Цель модульного теста
>todo
#### 217. Цель приемочного теста
>todo
#### 218. Цель системного теста
>todo
#### 219. Цель тестирования установки
>todo
#### 220. Цель функционального теста
>todo

## 27
#### 221. Аппендер - это объект, который определяет
>todo
#### 222. Библиотека log4j используется для
>todo
#### 223. Инварианты класса – это
>todo
#### 224. Методика проектирования по контракту
>todo
#### 225. Механизм утверждений (assertions) используется в Java для проверки
>todo
#### 226. Наивысший приоритет в log4j имеют сообщения с уровнем
>todo
#### 227. Наивысший приоритет среди представленных в log4j имеют сообщения с уровнем
>todo
#### 228. Наинизший приоритет в log4j имеют сообщения с уровнем
>todo
#### 229. Наинизший приоритет среди представленных в log4j имеют сообщения с уровнем
>todo
#### 230. Постусловия – это
>todo
#### 231. Предусловия - это
>todo
#### 232. Условная компиляция в Java позволяет
>todo
#### 233. Форматер нужен для определения
>todo

## 28
#### 234. Объект, представляющий собой окно программы и содержащий все объекты JavaFX-приложения называется
>todo
#### 235. Объект, представляющий физический контент JavaFX-приложения называется
>todo
#### 236. Основным паттерном, используемым при разработке JavaFX-приложения, является
>todo
#### 237. Разметка JavaFX-приложения хранится в файле с расширением
>todo
#### 238. Макет JavaFX, размещающий все компоненты приложения последовательно друг на друге, называется
>todo
#### 239. Макет JavaFX, добавляющий компоненты приложения в форме плиток одинакового размера, называется
>todo
#### 240. Одновременные манипуляции, выполняемые несколькими потоками, над графом сцены JavaFX
>todo
#### 241. Классы, применяемые для организации многопоточности в JavaFX, называются
>todo

## 29
#### 242. Этот интерфейс применяется при использовании статических SQL-запросов, не изменяющихся в процессе работы
>todo
#### 243. Этот интерфейс применяется, если SQL-запросы используют параметры, которые многократно изменяются в процессе работы
>todo
#### 244. Метод ```Statement```, возвращающий ```ResultSet```-объект, называется
>todo
#### 245. Интерфейс ```CallableStatement``` применяется для
>todo
#### 246. С помощью этого интерфейса можно получить доступ к данным, полученным оператором ```SELECT```
>todo
#### 247. По выборке, получаемой с помощью объекта ```ResultSet```, можно двигаться
>todo
#### 248. Выборка, получаемая с помощью ```ResultSet``` является
>todo
#### 249. Ключевая особенность транзакций -
>todo
#### 250. Типы данных JDBC
>todo
#### 251. Для закрепления изменений, произведенных транзакцией
>todo
#### 252. Для включения режима транзакций при наличии объекта ```Connection conn``` используется
>todo
#### 253. Для внесения изменений в таблицу базы данных
>todo

## 30
#### 254. При использовании ссылок на методы можно ссылаться на
>todo
#### 255. Функция является чистой, если
>todo
#### 256. Функция имеет высший порядок, если
>todo
#### 257. Функция не изменяет состояние, если
>todo
#### 258. Функциональный интерфейс — это
>todo
#### 259. Для сопоставления лямбда-выражения и интерфейса необходимо
>todo
#### 260. К встроенным функциональным интерфейсам Java не относится
>todo
#### 261. Функциональный интерфейс, представляющий функцию, принимающий один параметр и возвращающий единственное значение, это (выбрать наиболее подходящий)
>todo
#### 262. Функциональный интерфейс, представляющий функцию, принимающий один параметр и возвращающий булево значение, это (выбрать наиболее подходящий)
>todo
#### 263. Функциональный интерфейс, представляющий функцию, принимающий один параметр и возвращающий значение того же типа, это  (выбрать наиболее подходящий)
>todo
#### 264. ```Consumer``` — это функциональный интерфейс, представляющий функцию, которая
>todo
#### 265. Техника, которая комбинирует множественные функции в единую функцию, которая использует все комбинируемые функции, это
>todo
#### 266. Функциональная композиция предикатов может выполняться
>todo
#### 267. Функциональная композиция функций может выполняться
>todo
#### 268. Что такое Java Stream API
>todo
#### 269. Нетерминальная потоковая операция это
>todo
#### 270. Терминальная потоковая операция это
>todo
#### 271. К терминальным потоковым операциям не относится метод
>todo
#### 272. К терминальным потоковым операциям относится метод
>todo
#### 273. К нетерминальным потоковым операциям не относится метод
>todo
#### 274. К нетерминальным потоковым операциям относится метод
>todo
#### 275. К недостаткам Java Stream API относится
>todo
